//Рассмотрен пример на неориентированном графе. Поэтому вершины проходим дважды, по ребрам туда-обратно.
//1. Алгоритм поиска в глубину на основе списков смежности (adjacency lists или L). Списки смежности могут быть не отсортированы
//2. Алгоритм поиска в глубину на основе матрицы смежности (adjacency matrix или M)

//v (vertex) - текущая вершина графа
//переменной to обозначим номера соседей
//массив visited для пометки вершин, которые мы уже посетили, чтобы не было бесконечного цикла (например, из 0 в 1)
//для массива visited используем вектор интов, так как в этом массиве можно оставить и пометку о цвете вершины
//Оценка сложности поиска в глубину O(V+E), где V - вершина, E (Edge) - ребро
//В матрице смежности кол-во итераций цикла for равно кол-ву вершин в графе, поэтому сложность O(V^2)
//Вывод: лучше поиск в глубину делать на списках смежности!

//Задача 1. Проверим, можем ли мы из одной вершины (старт) пройти в другую (финиш) (проверка достижимости). Выводим "да" или "нет"
//Задача 2. Поиск компонент связности. От каждой вершины неориентированного графа можно добраться до всех остальных
// Если граф связный, то в массиве visited не должно быть нулей
// 
// Задача 3. Подсчет компонент связности
//Задача 3. Раскраска компонент связности в разные цвета. Добавляем в dfs component и в visited сохраняем уже не 1, а component
//раскраска компонент связности происходит с 0.


#include<algorithm>
#include <iostream>
//#include <Windows.h>
#include <vector>
#include <fstream>

using namespace std;

void dfs_L(vector<vector<int>> &graph, int v, vector<int>& visited, int component)//1. Алгоритм поиска в глубину на основе списков смежности.
{
	visited[v] = component;//как только пришли в вершину, помечаем ее как посещенную,
	               //и в итоге запускать цикл dfs будем не для всех вершин, а которые только равны 0 (не посещенные)

	for (int to : graph[v])
		if(visited[to] == -1)
		dfs_L(graph, to, visited, component);//рекурсивно идем к каждому соседу из заданной вершины, оставляя пометку в visited
}

//void dfs_M(vector<vector<int>>& graph, int v, vector<int>& visited)//2. Алгоритм поиска в глубину на основе матрицы смежности
//
//{
//	visited[v] = 1;//как только пришли в вершину, помечаем ее как посещенную,
//	//и в итоге запускать цикл dfs будем не для всех вершин, а которые только равны 0 (не посещенные)
//
//	for (int to = 0; to < graph.size; to++)//проходим по всей строке вершины v
//		if(graph[v][to] and !visited[to])//если на пересечении ячейки v и столбца to находится 1, значит существует ребро из v в to
//			                             //и если мы ранее не были в to, то можем рекурсивно запустить dfs
//		dfs_M(graph, to, visited);//рекурсивно идем к каждому соседу из заданной вершины, оставляя пометку в visited
//}

int main()
{
	//freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);Не работает

	ifstream read_file("input.txt");
	ofstream write_file("output.txt");

	int vertexCount, edgeCount;//кол-во вершин и ребер
	read_file >> vertexCount >> edgeCount; //считываим их

	vector < vector<int>> graph(vertexCount);//массив векторов для списка смежности графа

		for (int i = 0; i < edgeCount; i++)//считываем концы ребер и добавляем их в граф
		{
			int a, b;
			read_file >> a >> b;
			a--;
			b--;

			graph[a].push_back(b);//так как граф неориентированный
			graph[b].push_back(a);//то каждое ребро добавляем дважды, в ту и в др. стороны
		}

		//Для Задачи 1.
		//int start, finish;
		//read_file >> start >> finish;
		//start--;
		//finish--;


		vector<int> visited(vertexCount, -1);//запускаем цикл из вершины-старт и смотрим, посещена ли вершина-финиш
		int componentCount = 0;//счетчик для кол-ва компонент


		//Для Задачи 1.
		//if (visited[finish])//если в ячейке visited видим 1, то условие выполено
		//	write_file << "YES";
		//else
		//	write_file << "NO";

	    //Для Задачи 2.
		//if(find(visited.begin(), visited.end(), 0) == visited.end())//поиск в visited нолей
		//	write_file << "YES";
        //else
	    //  write_file << "NO";

		//Для Задачи 3.
		for (int v = 0; v < vertexCount; v++)//запуск поиска в глубину от каждой не посещенной ранее вершины
		{                                    //каждый запуск обрабатывает отдельную компоненту связности
			if (visited[v] == -1)
			{
				dfs_L(graph, v, visited, componentCount);
				componentCount++;
			}

		}
		//Для Задачи 3.
		/*write_file << componentCount;*/

		//Для Задачи 4.
		for(int color : visited)
			write_file << color << " ";

	//for (int v = 0; v < graph.size; v++)//запускаем цикл, 
	//{
	//	if (!visited[v])//если видим, что вершина еще не посещена
	//		dfs_L(graph, v, visited);//и для нее запускаем рекурсивный вызов dfs
	//}

		return 0;
}